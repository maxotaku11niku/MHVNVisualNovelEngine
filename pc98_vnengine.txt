--*-- PC-98 VN engine proposals --*--

* Foreword *

I have successfully made a sort of text engine backbone thingy, so perhaps I might make some sort of VN engine for the PC-98 or something. Making an *actual* VN would take time though, so that *might* be out of the question. But I'll make a note of these things, for reference.

As a note, my terminology will make very clear that VNs are not really 'games' most of the time.

* Folder Structure *

This is the root of the project, where both the main executable and supporting tools are located.

MHVN98: The PC-98 executable project folder. This is what a user would run to read a VN on a PC-98.
MHVNTEST: A testing space for the executables, with a minimal VN for purely testing purposes. Actual VNs would NOT be hosted here.
MHVNLINK: Links together the object versions of each data file, with a root descriptor to make all the required data files work properly.
MHVNTXAR: Bundles together all the text associated with one language to make a single .TXA file (output is embedded in an object file with linking information).
MHVNSCAS: Assembles scene scripts and bundles all of them together to make a single .DAT file (output is embedded in an object file with linking information).

Certain to come are authoring tools specific to this project (data packagers etc.).

What may come is a 'modern platform' executable so that people don't have to emulate a PC-98 (or use a real one) to read a VN.

What won't be hosted here are tools that are NOT specific to this project (image processor, PMD (which is developed by Masahiro Kajihara)).

* Feature List *

At minimum, I'm looking to put the following things into this engine:

* Rich text rendering (mostly done, just need to handle drawing to a proper graphical box)
* Changeable character sprites and CG images (I've already made a format and encoder/decoder, though I will definitely overhaul it soon)
* Music provided through PMD (I haven't programmed anything like this so this is the best way forward)
* Sound effects (I made an ADPCM format to keep file sizes down)
* Branching paths and the possibility of non-linear storylines (i.e. we want more than to just make 'kinetic' VNs)
* Save and load (including quicksave and quickload)
* Runs in real mode DOS (for simplicity. I use gcc-ia16 to compile my source code to an MZ .EXE file, and make sure it's 80286-compatible)

A few further features may be in order:

* Music room and CG gallery (in principle simple but not necessary)
* Cross-save persistence (time for some DDLC shenanigans??)
* Text log (common but not strictly necessary?)
* Voice acting support (again, that ADPCM format coming in)
* Video player (I've already written this one, actually. I would use it for intros perhaps)

Another important feature is that this engine should be data-driven. For the most part to create a radically different VN, one wouldn't have to recompile the executable. All unique information should be in data files. This would ease porting to modern systems, as all one would have to do is interpret those data files anyway. If a 'modern system' executable were made, further VNs could be made for the PC-98 and be automatically ported to modern systems. But that's all for later...

* System *

Here is an overview of the top-level state machine:

                                  when loading/starting anew
|-------| when finished  |------|---------------------------->|-----------|
| INTRO |--------------->| MENU |                             | STORYTIME |
|-------|                |------|<----------------------------|-----------|
                                         when quitting

This is so simple that it almost goes without saying, to be honest.

In any case the menu is simple to specify:

* You can start a new file, or load an existing one, beginning storytime.
* You can configure settings (like language?)
* You can listen to music and see the CGs.
* You can quit to DOS (unlike a few PC-98 games/VNs even if they're run from the hard drive rather than self-booting floppy disks)

Things only start to get interesting when we get to the storytime

* Storytime system *

When starting storytime, parameters relating to control of the system need to be set. These parameters are:

* The ID of the current scene
* The PC of the scene script interpreter
* The background image
* The background variant
* The character sprites to include
* The variant of each character sprite
* All custom state variables

On starting anew these are set to their default initial values, which are specified in a read-only file
On loading from a save file, of course these values are all set from the stored data

What should this system be doing every frame? First of all, on loading the following events occur:

* The appropriate scene data is loaded and the PC zeroed
* The background image is loaded and drawn and the appropriate variant is applied
* The music is loaded and starts to fade in (after fade out from the menu is complete)
* The fade in begins and the effect is slowly applied over some time (about a second or two?)
* The text box and name box (if appropriate) are loaded and drawn
* Any appropriate character sprites are loaded and drawn and variants applied
* The current speaker's name is written into the name box if applicable
* The rendering of the text starts. This takes some time, but it can be skipped with the 'advance' key

And after this first text box has been fully drawn and when the engine is idle, what happens next depends on the user's input:

* If the user simply presses the 'advance' key then the engine restarts script processing
* If the user presses the 'quick save' key, then the engine quickly saves the story state into a file
* If the user presses the 'quick load' key, then the engine prompts the user to confirm quick load. After receiving confirmation, the engine fades out and does the usual load from save file behaviour
* If the user presses the 'save' key, then the engine shows the save dialog, listing files to save to or asking to save to a new file. By default, the last saved to file is chosen, unless there has been no saves yet this session then it will be the file loaded from, unless the story was started anew. After confirmation, the save is carried out
* If the user presses the 'load' key, then the engine shows the load dialog, listing files to load from. After confirmation, the engine fades out and does the usual load from save file behaviour
* If the user presses the 'view log' key, then the engine shows the chat log, which can be scrolled through
* If the user presses the 'quit' key, then the engine prompts the user to confirm the quit, After confirmation, the engine fades out and quits to menu

When a restart of script processing is requested by the user pressing the 'advance' key, one thing that should always happen is that the text in the text box be wiped. The following actions may also happen:

* By default the next set of text is written over time
* If the character name is to be changed, the old name is wiped from the name box and the new name written in (instantly, as usual)
* If a character sprite is to be changed, it may have a variant applied (to show different emotions), it may also be introduced or removed
* If the music is to be changed, it can be changed with a fade out or instant cut, it can even be silenced completely
* If a special effect is to be applied, it can take place before the text wipe or after. This includes sound effects
* Delays between actions can be specified arbitrarily
* If the script execution reaches a decision point, then all the valid decisions are presented to the user in a nice box. The decisions presented may depend on state variables. State variables can be changed based on the decision made by the user, and these state variables can control where script execution goes next
* If the end of the scene has been reached, then the engine wipes character sprites, then the text box itself and then fades out. The music may fade out or cut, or simply continue into the next scene. Upon loading the next scene, the sequence presented before is applied

If the end of the scene has been reached, but that end of scene specifies that it's now the end of the whole story, then the credits will roll. Remember to do the wrap-up *before* the technical end!

* Data formats *

What follows are some details on the data formats for this engine

* External requirements *

For the purposes of playing music, the executable expects to be able to call PMD, so some PMD instance should already be loaded. This instance must be unloaded when the user quits. Handle this through a batch file or something. PMDWin or something similar should be used for a 'modern system' executable (i.e. emulating the YM2608 and interpreting .M and .M2 files as PMD would do)

* Master VN descriptor (ROOTINFO.DAT) *

This file contains references to all other data files needed and some info on global VN details. It is the only file path for read-only data hardcoded into the executable, so the engine *needs* to find a ROOTINFO.DAT.

0x00	char[4]		magic_num	"MHVN" in ASCII. This magic number is here just as a sanity check to make sure that this ROOTINFO.DAT is actually valid before finding out the hard way.
0x04	uint16		VNflags		Some flags to control high-level behaviour
0x06	uint16		numstvar_glob	Number of global (save independent) variables to reserve
0x08	uint16		numflags_glob	Number of global (save independent) bitflags to reserve
0x0A	uint16		numstvar_loc	Number of save-local state variables to reserve
0x0C	uint16		numflags_loc	Number of save-local bitflags to reserve
0x0E	uint16		format_norm	Default format number for normal text
0x10	uint16		format_char	Format number for character name text
0x12	uint16		format_menu_notsel	Format number for menu text that is not selected
0x14	uint16		format_menu_sel	Format number for menu text that is selected
0x16	char[12]	scenedat_file	The filename of the scene data archive, where all scene data is stored. Null terminated
0x22	char[12]	langdat_file	The filename of the language metadata archive, where every language supported is listed and all corresponding text files given. Null terminated
0x2E	char[12]	bgdat_file	The filename of the background image data archive, where all BGs and CGs are stored. Null terminated
0x3A	char[12]	sprdat_file	The filename of the sprite data archive, where all sprite data is stored. Null terminated
0x46	char[12]	musdat_file	The filename of the music data archive, where all music data is stored. Null terminated
0x52	char[12]	sedat_file	The filename of the sound effect data archive, where all sound effect data is stored. Null terminated
0x5E	char[12]	systemdat_file	The filename of the system data archive, where the menu image, intro sequence and text box images are stored, for example. Null terminated

VNflags has the following definition:

0000 0000  0000 0PMC
C - Present CG gallery? Option is hidden from the menu if 0
M - Present music room? Option is hidden from the menu if 0
P - Custom protagonist support?

* Scene data archive (scenedat_file) *

This file contains all the necessary scene data used to control the story. It only refers indirectly to the text, which is all stored in another file.

0x00000000	uint16			num_scenes	Total number of scenes
0x00000002	uint16			num_chars	Total number of characters
0x00000004	uint32[num_scenes]	sceneptrs	Pointers to each of the starts of scene data
var		scene_data[num_scenes]	scenedats	A list of compressed scene datas. The uncompressed size of each scene data must not exceed a certain threshold

For each scene, when the data is uncompressed, it takes the form of a bytecode, where we have the following opcodes:

0x00	gotoscene [uint16 scene_num]       Ends the current scene and goes to another scene. Scene number 0xFFFF is reserved for the end of the story (vnend pseudoinstruction).
0x01	jmp [int16 relative_offset]        Jumps by some relative offset unconditionally. The offset is relative to the end of this instruction.
0x02	jz, je [int16 relative_offset]     Jumps by some relative offset if the Z flag is set. The offset is relative to the end of this instruction.
0x03	jnz, jne [int16 relative_offset]   Jumps by some relative offset if the Z flag is not set. The offset is relative to the end of this instruction.
0x04	jn, jl [int16 relative_offset]     Jumps by some relative offset if the N flag is set. The offset is relative to the end of this instruction.
0x05	jp, jge [int16 relative_offset]    Jumps by some relative offset if the N flag is not set. The offset is relative to the end of this instruction.
0x06	jle [int16 relative_offset]        Jumps by some relative offset if the N flag is set or the Z flag is set. The offset is relative to the end of this instruction.
0x07	jg [int16 relative_offset]         Jumps by some relative offset if the N flag is not set and the Z flag is not set. The offset is relative to the end of this instruction.
0x08	palsetcol [uint5 red], [uint5 green], [uint5 blue]    Sets the mix palette to a single colour. These values are bitpacked into 2 bytes.
0x09	paladdcol [int5 red], [int5 green], [int5 blue]       Sets the mix palette to the main palette plus a fixed colour. These values are bitpacked into 2 bytes.
0x0A	palsetlum [int8 luminositymod]                        Sets the mix palette to the main palette but with the luminosity modified. +127 means white, -128 means black, 0 means no change.
0x0B	palsetsat [uint8 saturationmod]                       Sets the mix palette to the main palette but with the saturation modified. Saturation is multiplied by saturationmod/128.
0x0C	palsethue [int8 huemod]                               Sets the mix palette to the main palette but with the hue modified. Hue is rotated by (huemod/128) * 180 degrees.
0x0D	palcolourise [uint5 red], [uint5 green], [uint5 blue] Sets the mix palette to the main palette but each colour's chrominance is made the same as the given colour. These values are bitpacked into 2 bytes.
0x0E	palinvert                                             Sets the mix palette to the main palette but inverted.
0x0F	nowait                                                Instead of waiting for a certain condition before continuing, continues until the next instruction that requires waiting. Actions started by the previous instruction will still be carried out unless another instruction overrides them. Not effective for instructions that wait for user input before continuing.
0x10	nexttext                           Displays the next text and waits for user input before continuing. Cannot actually be used in scene assembly, generated automatically by the assembler from sequential 'text' commands.
0x11	text [uint16 textnum]              Displays the text given in the following local string reference and waits for user input before continuing.
0x12	charname [uint16 charnum]          Sets the current character name to the string pointed to by charnum. Character number 0xFFFF is reserved for wiping the character name entirely (nocharname pseudoinstruction).
0x13	deltext                            Wipes the text from the text box. Implied by a 'text' instruction if not called beforehand.
0x14	ynchoice                           Displays a yes/no choice to the user. Sets the Z flag to 0 if no, or to 1 in if yes.
0x15	choice2 [uint16 statevar], [label opt1], [label opt2]  Displays two freeform choices to the user and puts the number chosen into the state variable pointed to by statevar. Waits for user input before continuing. Converted by the assembler into the more space efficient encoding which is what is actually parsed by the scene processor: choice2 [uint16 statevar], [uint16 firstchoicetext].
0x16	choice3 [uint16 statevar], [label opt1], [label opt2], [label opt3]  Displays three freeform choices to the user and puts the number chosen into the state variable pointed to by statevar. Waits for user input before continuing. Converted by the assembler into the more space efficient encoding which is what is actually parsed by the scene processor: choice3 [uint16 statevar], [uint16 firstchoicetext].
0x17	choice4 [uint16 statevar], [label opt1], [label opt2], [label opt3], [label opt4]  Displays four freeform choices to the user and puts the number chosen into the state variable pointed to by statevar. Waits for user input before continuing. Converted by the assembler into the more space efficient encoding which is what is actually parsed by the scene processor: choice4 [uint16 statevar], [uint16 firstchoicetext].
0x18	bfadein [uint3 amount], [uint5 speed]  Fades in from black, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x19	bfadeout [uint3 amount], [uint5 speed] Fades out towards black, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x1A	wfadein [uint3 amount], [uint5 speed]  Fades in from white, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x1B	wfadeout [uint3 amount], [uint5 speed] Fades out towards white, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x1C	pfadein [uint3 amount], [uint5 speed]  Fades towards the mix palette, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x1D	pfadeout [uint3 amount], [uint5 speed] Fades towards the main palette, by a proportion of (amount+1)/8 at a rate of (speed+1)/2 steps (out of 255 total for a full fade) every 1/56.4th of a second. Waits for the effect to finish before continuing. These values are bitpacked into one byte.
0x1E	phuerotate [uint8 speed]               Rotates the hue of the display palette at a rate of ((speed+1)/1024) * 360 degrees per 1/56.4th of a second. If speed is 0, resets display palette to main palette and stops the effect. Therefore, script execution won't be stopped by this instruction.
0x1F	shake [uint6 amplitude], [uint5 period], [uint5 damping] Starts a vertical screen shake effect, where the maximum displacement from zero is amplitude pixels, the period of the shaking is (period+1)/28.2 seconds, and the amplitude is damped through a multiplier of ~1-(damping/2048) every frame. Waits for the amplitude to reach zero before continuing. Note that if damping is 0, the shaking will continue forever, which could softlock if you don't use a nowait instruction.
0x20	lut2 [uint16 statevar], [int16 lut1], [int16 lut2]  2-element lookup table using statevar as an index and putting the result into statevar.
0x21	lut3 [uint16 statevar], [int16 lut1], [int16 lut2], [int16 lut3]  3-element lookup table using statevar as an index and putting the result into statevar.
0x22	lut4 [uint16 statevar], [int16 lut1], [int16 lut2], [int16 lut3], [int16 lut4]  4-element lookup table using statevar as an index and putting the result into statevar.
0x23	swapzn                                        Swaps the Z and N flags.
0x24	setvi [uint16 statevar], [int16 imm]          Sets *statevar to equal imm.
0x25	setvv [uint16 statevar1], [uint16 statevar2]  Sets *statevar1 to equal *statevar2.
0x26	csetvi [uint16 statevar], [int16 imm]         Sets *statevar to equal imm if the Z flag is set, otherwise don't do anything.
0x27	csetvv [uint16 statevar1], [uint16 statevar2] Sets *statevar1 to equal *statevar2 if the Z flag is set, otherwise don't do anything.
0x28	cmpvi [uint16 statevar], [int16 imm]          Sets flags according to the result of *statevar - imm.
0x29	cmpvv [uint16 statevar1], [uint16 statevar2]  Sets flags according to the result of *statevar1 - *statevar2.
0x2A	addvi [uint16 statevar], [int16 imm]          Performs *statevar += imm, and sets the flags according to the result.
0x2B	addvv [uint16 statevar1], [uint16 statevar2]  Performs *statevar1 += *statevar2, and sets the flags according to the result.
0x2C	subvi [uint16 statevar], [int16 imm]          Performs *statevar -= imm, and sets the flags according to the result.
0x2D	subvv [uint16 statevar1], [uint16 statevar2]  Performs *statevar1 -= *statevar2, and sets the flags according to the result.
0x2E	ldflg [uint16 flag]                           Loads flag into the Z flag. If 'flag' actually refers to a variable, then Z is set only if the variable is nonzero, otherwise Z is unset.
0x2F	stflg [uint16 flag]                           Puts the Z flag into the given flag. If 'flag' actually refers to a variable, then the operation is forbidden (for safety reasons).
0x30-0x3F Reserved, priority for new allocations
0x40-0xFF Reserved, will only be used for new instructions if absolutely necessary

The scene assembler also has the following directives:
.scene [scene_name]     Declares a scene with the following name. Make sure that scene has the appropriate text entries for all supported languages. Every line until the next .scene directive or the end of the file is assumed to be part of the declared scene.
.vnentry                Declares that this scene is the first scene in the VN, that is, the scene that will be loaded when the user wishes to start a new save file. Put this directly after the .scene directive of the scene you want to come first. Do not declare this more than once across the whole project.
.globvar [name]         Declares a new global variable with the following name. These variables are shared between save files, so you can use them for funky cross-save shenaningans. You can delete your save, but the game always remembers...
.globflag [name]        Declares a new global flag with the following name.
.localvar [name]        Declares a new local variable with the following name. These variables are kept separately for each save file.
.localflag [name]       Declares a new local flag with the following name.


* State variable address space *

All variables that can be accessed with instructions live in a 16-bit address space, thus there can be a maximum of 65536 in theory.
However, the address space is heterogenous, and the following table lays out the address assignments:

 Address range | Assignment
---------------|----------------------------
 0x0000-0x001F | Scratch variables (therefore there are 32)
 0x0020-0x007F | Scratch flags (therefore there are 96)
 0x0080-0x00FF | Global variables (therefore limit is 128)
 0x0100-0x03FF | Global flags (therefore limit is 768)
 0x0400-0x05FF | Local variables (therefore limit is 512)
 0x0600-0x0FFF | Local flags (therefore limit is 2560)

Now for some definitions:
Scratch  - Meant to be used as temporary scratch space, available by default (as r0-r31 and f0-f95).
Global   - Saved across save files, must be allocated for use.
Local    - Saved separately to each save file, must be allocated for use.
Variable - 16 bit signed integer.
Flag     - A single bit, which functions as a boolean value (true/false, yes/no).

The upper 4 bits are unused for compatibilty with text escape codes 0x8x and 0xAx.

* Language data descriptors (langdat_file) *

This file contains a list of filenames of associated text data archives. 

0x00000000	uint16			num_lang		Number of languages supported
0x00000002	uint32[num_lang]	textdat_file_ptrs	Pointers to a language's text data file
var		char[][num_lang]	textdat_files		A list of filenames of text data files, one for each language supported

Adding support for multiple languages is therefore a case of adding to this list, and adding the necessary text data file. One must make sure that the text metadata is consistent between languages.

* Text data archive (textdat_file) *

This file contains all the text for a single language.

0x00000000	uint32	systext_ptr	Pointer to the system text strings
0x00000004	uint32	credits_ptr	Pointer to credits text strings
0x00000008	uint32	charnames_ptr	Pointer to character names
0x0000000C	uint32	scenetext_ptr	Pointer to the scene texts structure
0x00000010	uint32	cgtext_ptr	Pointer to the CG names structure (can be 0 if there is no CG gallery)
0x00000014	uint32	musictext_ptr	Pointer to the music names and comments structure (can be 0 if there is no music room)

What immediately follows this header is all the system text strings (usually). Each section of this file contains text in different formats.

System text:
	char[]	system_text	Every system-relevant text string, in the prescribed order, given below:

	LANGNAME		The native name of the language (e.g. for ja_JP this should be 日本語)
	SYS_MENU_NEWSTORY	"Start New", in the main menu
	SYS_MENU_CONTINUE	"Continue", in the main menu
	SYS_MENU_CONFIG		"Options", in the main menu
	SYS_MENU_QUIT		"Quit", in the main menu
	SYS_MENU_GALLERY	"CG Gallery", in the main menu
	SYS_MENU_MUSICROOM	"Music Room", in the main menu

	Note that this only the order the strings must appear in the final text archive, they can be specified in any order in the source files (though I recommend putting all of them into one file) MHVNTXAR will substitute the appropriate English strings if these strings aren't found in the source files. So don't forget them if you're writing for non-English speakers, or if you want to add some *flair* to your menus.

Credits text:
	char[]	credits_text	The entire text of the original creator's credits. Note that at the end will be a hardcoded small note that I created the engine :)

Character names:
	uint16[num_chars]	charnames_ptrs	Pointers to each character's name
	char[]			charnames_text	Array of character names

CG text:
	uint16[num_cg]	cgnames_ptrs	Pointers to all the CG names
	char[numCGs][]	cgnames_text	The CG names

Music names and comments:
	uint16[num_songs]	musicinfo_ptrs	Pointers to all the music names and comments
	char[num_songs][]	musicinfo_text	The name of each song followed by the comment for it (the pattern goes NCNCNCNC... and the pointer points to the name first)

Scene text:
	uint32[num_scenes]	scenetext_ptrs	Pointers to each scene's full text
	For each scene:
	uint16			num_strings	Total number of strings
	uint16[num_strings]	text_ptrs	Pointers to each string in the scene
	char[num_strings][]	text_array	Array of all text in the scene (compressed)
	

Text may be given formatting information through 0x1B (the escape character). What the byte after 0x1B does depends:

0x0x	Doesn't do anything, acts as null terminate if x is 0
0x1x	Main formatting flags (x -> SUIB: B - bold, I - italic, U - underline, S - shadow)
0x2x	Reserved
0x3x	Final fade value selector (x -> level of fade, 0 - no fade -> F - very nearly invisible)
0x4x	Colour selector (x -> palette value)
0x5x	Custom protagonist information inject, out of 16 slots (not all of which have to be filled) (x -> information ID)
0x6x	Wait for 10*(x+1) frames before continuing
0x7x	Set wait between characters to (x+1) frames
0x8x	Insert variable value as signed integer (x indicates bits 8-11 of the address, byte following this one indicates bits 0-7)
0x9x	Reserved (may be used to double the variable address space)
0xAx	Use flag to switch between texts (x indicates bits 8-11 of the address, byte following this one indicates bits 0-7)
0xBx	Reserved (may be used to double the variable address space)
0xCx	Reserved
0xDx	Reserved
0xEx	Reserved
0xFx	Reset formatting to default for some parameter (x -> CFTM: M - main, T - font, F - fade, C - colour)

The operation of the 0xAx escape code is quite different to other escape codes.
The two texts to switch between are separated by a 0x1A (SUB control) and a 0x03 (ETX control) ends the escape block.
The first text displays if the flag is unset, and the second displays if the flag is set. For example:

Am I right? \x1B\xA0\x20No, heck no.\x1AYESYESYES!\x03 ...Anyway.

would display as:

Am I right? No, heck no. ...Anyway.

if f0 was unset and as:

Am I right? YESYESYES! ... Anyway.

if f0 was set.
The format implies that you can use other escape codes just fine, and yes you can nest these. But don't be crazy.

* MHVNTXAR input *

Most of this will be literal text, though of course there are control sequences in the input files to do formatting etc. All control sequences start with an '@', and numerical inputs are currently hex only (sorry):

@@	Becomes a single @.
@[	Opens a normal text entry. The text between this and the next newline is the entry's label, and after the newline until the end of the entry is the text of the entry. If a reserved label is used, then it corresponds to system text. Otherwise, a scene has to be declared beforehand.
@]	Ends a normal text entry. @[ and EOF can be taken as the end of an entry if @] is not found first.
@s(l)	Declares a scene with label 'l' and makes the text in every following normal entry associated with that scene.
@n(l)	Declares a character with label 'l' and all the immediately following text until the next newline is that character's display name.
@f(f)	Sets the text formatting, where 'f' is a formatting flag (b -> bold, i -> italic, u -> underline, s -> shadow). Combine multiple letters to set multiple formatting flags at once.
@mn	Sets the fade level to 'n'.
@cn	Sets the colour to index 'n'.
@pn	Insert custom protagonist information unit 'n'.
@dn	Wait for 10*(n+1) frames before continuing.
@wn	Set the wait between characters to (n+1) frames.
@v(l)	Insert the value of the variable named 'l' as a signed 16-bit integer.
@b(f)n@yy	Switch between the text 'n' and 'y' depending on the state of flag 'f': 'n' if 'f' is unset, 'y' if 'f' is set.
@r(f)	Reset formatting to default for some parameter (f -> format, m -> fade, c -> colour). Combine multiple letters to reset multiple format parameters at once.

* BG data archive (bgdat_file) *

This file contains all 'background' images. A 'CG' image is just another kind of background image, but by convention no sprites are shown in front of one. The corresponding variant patches are also stored here.

* Sprite data archive (sprdat_file) *

This file contains all sprite images, as well as their corresponding variant patches.

* Music data archive (musdat_file) *

This file contains all music data for PMD.

* Sound effect data archive (sedat_file) *

This file contains all sound effect data.

0x00000000	uint32                     globaleffect_ptr   Pointer to table of pointers to global sound effects
0x00000004	uint32                     scenespecific_ptr  Pointer to table of pointers to scene-specific sound effect tables
0x00000008	uint16                     num_globeleffects  Number of global sound effects
0x0000000A	uint32[num_globaleffects]  globaleffect_table Pointers to global sound effect data
var         uint32[num_scenes]         sceneptrs_table    Pointers to tables of pointers to scene-specific sound effects

And then for every scene:

0x00000000  uint16                     num_effectsinscene Number of sound effects associated with this scene
0x00000002  uint32[num_effectsinscene] sceneeffect_table  Pointers to sound effects associated with this scene

All sound effects are 534ADPCM files. Global sound effects can be triggered from anywhere, scene-specific sound effects can only be triggered from the scene they are associated with.
'Scene-specific' sound effects were mostly invented to provide voice acting support, should one choose to use it. For the sake of saving space, please use a low sample rate and encode voice files to mono. Human voices can still sound recognisable even down to 5000 Hz sample rate and maybe lower. 11025 Hz feels fine enough. Of course, because of the abstraction (this specification doesn't care one bit what the actual audio in the file is) you could put whatever you want.

Please do not abuse this system to provide full PCM background music, as I cannot guarantee that MHVN98 will provide sound effect mixing support. This means perhaps only one sound effect can play at any one time.

See the specification on 534ADPCM for more info on the actual content of the sound files.

* System data archive (systemdat_file) *

This file contains data relevant for the whole system, and is used to customise the basic look and feel of the VN.

* Config file and global save data (GLOBAL.CFG) *

This file contains settings and global save data. The latter allows previous playthroughs to affect later playthroughs, enabling behaviour sort of like that seen in Doki Doki Literature Club or Undertale.

* Save data files (XXXXXXXX.SAV, QUICK.SAV, AUTO.SAV) *

These files contain individual data for playthroughs, sufficient to restore the state of the VN to how it was before the save.

0x00000000	uint32		checksum	Checksum of all the data in this file (from 0x00000004 onwards) to check data integrity
0x00000004	uint16		scenenum	The scene number at the time of saving
0x00000006	uint16		scenepc		The scene bytecode program counter to return to upon loading
0x00000008	int64		timestamp	Unix-style timestamp recording the time this file was written to
0x00000010	int16[numstvar]	statevar	Stores the current value of all state variables
var		char[]		bootstrap_code	Bytecode required to restore the state as it was when this file was saved. Null terminated
